## 算法复杂度
* 代表最坏情况的用时
* 10<sup>8</sup> ~秒级
  * O(N!),O(2<sup>N</sup>),O(N<sup>2</sup>),O(NlogN),O(N),O(logN)...
  * 最大的N大约分别为:10, 30, 10000, 10^7,10^8,天文
## 分析
由数据量反推我们需要一个怎样的算法
### O(N<sup>2</sup>)
* 两层for循环
```java
for(int i=0; i<n;i++){
  for(int j=i; j<n; j++){
    //...
    //something...
  }
}
```
* 插入排序,选择排序
### O(NlogN)
* 有N个元素,一分为二,进行递归 
* N个元素,为了将其分为两半,需要对N个元素进行扫描才能将元素 分开,要logN轮
```xml  
                    N
      ┌─────────────────────────→  
      │       □□□□□□□□□□□□  
logN  │     □□□□□□       □□□□□□       f([......])→f([...])+f([...])→...
      │   □□□    □□□   □□□   □□□□  
      ↓  
```

* 归并排序,快速排序(平均)
### O(logN)
* 并不需要扫描,因为元素本来就是有序的
```xml  
                    
      ┌─────────────────────────→  
      │        □□□□□□□□□□□□  
logN  │     □□□□□□      ...       
      │   ...    □□□   
      ↓  
```
* 二分查找
## 算法的组合
* 不同算法组合起来的复杂度
  * 区间合并:给定一系列区间,合并它们,可以先将其按照左端点进行排序,然后按右端点比较
  * 排序O(NlogN)+扫描已排序的列表O(N) = O(NlogN)
* 递归
  * 每个节点都访问一次吗?
  * 输出多少东西
  * 每个节点访问的时间是常数吗
## 估算算法时间
* 2<sup>31</sup>-1~>900_000_000
* 计算机在秒级内运算10<sup>8</sup>的数据
* 一年525600分钟315_360_00秒