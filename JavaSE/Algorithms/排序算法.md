# 时间复杂度 O(N<sup>2</sup>)

## 冒泡排序
* 首先交换0 到 n-1数组整体
* 第一个数和第二个数进行比较,大的放在后边
* 第二个和第三个进行比较,递归比较操作,
* 最后最大的数字会到数组最后n-1的位置
* 然后将范围缩小为0 到 n-2,重复递归比较,第二大的数字会到n-2倒数第二的位置
* 重复范围缩小的递归

##　选择排序
* 首先在数组0 到 n-1上选出一个最小值,放在位置0上
* 然后在数组1 到 n-1上选出最小值,放在位置1上
* 重复以上操作

## 插入排序

* 首先位置0上的数字和位置1上的数字进行比较,最小的放在前边
* 位置2上的数与前面的数字进行比较,如果比位置1上的数小,则与其交换,接着与位置1上的数进行比较,更小则交换
* 对于位置K上的值B,则B对0到K-1上每个位置的数进行比较,
  * 若B一直小于之前的数,则一直进行交换,
  * 直到之前的数字小于等于B时,则插入当前位置

# 时间复杂度 O(N*logN)

## 归并排序

* 首先使数组中每个元素分隔为长度为1的(有序)区间{长度为一只与自己比较自然有序}
* 然后合并相邻长度为一的区间,得到最大长度为2的有序区间(元素间需要比较)
* 继续合并相邻有序区间得到最大长度为2<sup>n-1</sup>的有序区间
* 直到数组元素合并成一个区间


## 快速排序

* 思想: 在数组中随机的选择一个数字 小于它的放在数组的左边,大于它的放在它的右边,对其左右递归调用这个比较过程
* Partition过程,完整划分过程:
* {小于等于区间}[比较值,,,当前,,,,,,,划分值]
  * 首先选取一个划分值,将其置于数组最后位置
  * 设置一个`小于等于区间`,初始时长度为0,放在数组的左边
  * 从左到右遍历比较数组元素,
    * 大于划分值的跳过,继续遍历下一个,
    * 当前元素小于等于划分值的,将当前数与小于等于区间的下一个数进行交换,
    * 将小于等于区间向右移动一个位置
  * 当所有元素遍历完毕,将划分值与小于等于区间的下一个元素进行交换
  * 以上即为一次完整的划分过程,时间复杂度为O(N)
  * 对划分值左右递归以上过程

## 堆排序

* 将数组中的n个元素建成一个大小为N的根堆,
  * 堆顶为数组元素的最大值,将其与最后一个元素进行交换,
  * 脱离堆最后一个元素放在数组最后一个位置,作为数组的有序部分
* 将数组中n-1大小的元素与堆顶位置进行根堆的调整,调整出一个n-1的最大值作为堆顶,将其与堆为交换,并脱离放入数组中
* 此时堆的大小从N-1到N-2,继续以上调整,交换,脱离步骤,这样堆大小依次减一,数组大小依次增加,当堆大小减为一时,数组有序

## 希尔排序

* 思想: 改良型插入排序,将步长为一的比较改为步长为K的比较,
* 进行步长为K-1,K-2...,直到步长为1的比较.
* 希尔排序的关键在于其步长的选择,越优时间复杂度越低,越劣越趋于O(N<sup>2</sup>)级别

# 时间复杂度 O(n<sup>2</sup>)

# 时间复杂度 O(n<sup>2</sup>)
# 时间复杂度 O(n<sup>2</sup>)