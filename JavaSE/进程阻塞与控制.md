# 进程阻塞与控制
参照:
> [多线程.二](http://www.cnblogs.com/lwbqqyumidi/p/3817517.html)  
## 线程的调度
1. 调整线程优先级:
    * Java线程有优先级,优先级高的线程会获得较多的执行机会.每个线程都有默认的优先级.每个线程默认的优先级都与创建它的线程的优先级相同.main线程默认具有普通优先级.

    * Java线程的优先级用整数表示,用`setPriority(int priorityLevel)`和`getPriority()`方法分别用来设置和获取线程的优先级.取值范围是1~10,但与常见的操作系统都不能很好的映射.如果希望程序能移植到各个操作系统中,Thread类有以下三个静态常量能保证不同系统采用了同样优先级的调度方式:
    ```java
    static int MAX_PRIORITY  
          //线程可以具有的最高优先级,取值为10.  
    static int MIN_PRIORITY  
          //线程可以具有的最低优先级,取值为1.  
    static int NORM_PRIORITY  
          //分配给线程的默认优先级,取值为5.  
    ```
    * 具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会,而非优先执行.
2. 线程睡眠:`Thread.sleep(long millis)`方法,使线程转到阻塞状态.millis参数设定睡眠的时间,以毫秒为单位.当睡眠结束后,就转为就绪(Runnable)状态.`sleep()`平台移植性好.  
3. 线程等待:Object类中的`wait()`方法,导致当前的线程等待,直到其他线程调用此对象的 `notify()`方法或`notifyAll()`唤醒方法.这两个唤醒方法也是Object类中的方法,行为等价于调用wait(0).  
4. 线程让步:`Thread.yield()`方法,暂停当前正在执行的线程对象,把执行机会让给相同或者更高优先级的线程.  
5. 线程加入:`join()`方法,等待其他线程终止.在当前线程中调用另一个线程的`join()`方法,则当前线程转入阻塞状态,直到另一个进程执行结束,当前线程再由阻塞转为就绪状态.  
6. 线程唤醒:Object类中的`notify()`方法,唤醒在此对象监视器上等待的单个线程.如果所有线程都在此对象上等待,则会选择唤醒其中一个线程.选择是任意性的,并在对实现做出决定时发生.线程通过调用其中一个wait方法,在对象的监视器上等待.直到当前的线程放弃此对象上的锁定,才能继续执行被唤醒的线程.被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争;例如,唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势.类似的方法还有一个notifyAll(),唤醒在此对象监视器上等待的所有线程.
### 常见线程名词解释
主线程:JVM调用程序main()所产生的线程.
当前线程:这个是容易混淆的概念.一般指通过Thread.currentThread()来获取的进程.
后台线程:指为其他线程提供服务的线程,也称为守护线程.JVM的垃圾回收线程就是一个后台线程.用户线程和守护线程的区别在于,是否等待主线程依赖于主线程结束而结束
前台线程:是指接受后台线程服务的线程,其实前台后台线程是联系在一起,就像傀儡和幕后操纵者一样的关系.傀儡是前台线程.幕后操纵者是后台线程.由前台线程创建的线程默认也是前台线程.可以通过isDaemon()和setDaemon()方法来判断和设置一个线程是否为后台线程.
## 控制方法

1. join()
  * 让一个线程等待另一个线程完成才继续执行.如A线程线程执行体中调用B线程的join()方法,则A线程被阻塞,直到B线程执行完为止,A才能得以继续执行.
  * join是Thread类的一个方法,启动线程后直接调用,
  * 为什么要用join()方法
    * 在很多情况下,主线程生成并起动了子线程,如果子线程里要进行大量的耗时的运算,主线程往往会于子线程之前结束,而此时如果主线程处理完其他的事务时,需要用到子线程的处理结果,因此主线程需要等待子线程执行完成之后再结束,这个时候就要用到join()方法了.
2. sleep(long millis): 
  * 让当前的正在执行的线程暂停指定的时间,进入停滞状态(阻塞当前线程),使当前线程让出CUP的使用,避免独霸CPU资源,
  * 在其睡眠的时间段内,该线程由于不是处于就绪状态,不会得到执行的机会.即使此时系统中没有任何其他可执行的线程,sleep()中的线程也不会执行,因此sleep()方法常用来暂停线程执行.
  * sleep()是Thread类的Static(静态)的方法;因此他不能改变对象的机锁,所以当在一个Synchronized块中调用Sleep()方法是,线程虽然休眠了,但是对象的机锁并木有被释放,其他线程无法访问这个对象(即使睡着也持有对象锁).
  * 在sleep()休眠时间期满后,该线程不一定会立即执行,这是因为其它线程可能正在执行而且没有被调度为放弃执行,除非此线程具有更高的优先级. 
  * 前面有讲到,当调用了新建的线程的start()方法后,线程进入到就绪状态,可能会在接下来的某个时间获取CPU时间片得以执行,如果希望这个新线程必然性的立即执行,直接调用原来线程的sleep(1)即可.[关于sleep(1)](https://stackoverflow.com/questions/1413630/switchtothread-thread-yield-vs-thread-sleep0-vs-thead-sleep1)
3. setDaemon():
  * 后台线程,主要是为其他线程(相对可以称之为前台线程)提供服务,或"守护线程".如JVM中的垃圾回收线程.
  * 生命周期:后台线程的生命周期与前台线程生命周期有一定关联.主要体现在:当所有的前台线程都进入死亡状态时,后台线程会自动死亡
  * 设置后台线程:调用Thread对象的setDaemon(true)方法可以将指定的线程设置为后台线程.
  * 判断线程是否是后台线程:调用thread对象的isDeamon()方法.main线程默认是前台线程,前台线程创建的子线程默认是前台线程,后台线程中创建的线程默认是后台线程.调用setDeamon(true)方法将前台线程设置为后台线程时,需要在start()方法调用之前.前台线程都死亡后,JVM通知后台线程死亡,但从接收指令到作出响应,需要一定的时间.
4. yield():
  * 暂停当前正在执行的线程对象,并执行其他线程.
  * yield()是让当前执行线程回到可执行状态,以允许具有相同优先级或更高优先级的其他线程获得执行机会.因此,使用yield()的目的是让相同优先级的线程之间能适当的轮转执行.
  * 实际中无法保证yield()达到让步目的,因为让步的线程还有可能被线程调度程序再次选中.
5. setPriority(): 更改线程的优先级.
6. interrupt():
  * 只是给线程发送一个中断信号,让线程在无限等待时(如死锁时)能抛出抛出,从而结束线程,但如果你忽略此异常,那么这个线程还是不会中断
7. 其他常用方法
    * isAlive(): 判断一个线程是否存活.  
    * activeCount(): 程序中活跃的线程数.   
    * enumerate(): 枚举程序中的线程.   
    * currentThread(): 得到当前线程.   
    * isDaemon(): 一个线程是否为守护线程.   
    * setName(): 为线程设置一个名称.  
    * `wait()`:导致当前线程等待并使其进入到等待阻塞状态.直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程.  
    * `notify()`:唤醒在此同步锁对象上等待的单个线程,如果有多个线程都在此同步锁对象上等待,则会任意选择其中某个线程进行唤醒操作,只有当前线程放弃对同步锁对象的锁定,才可能执行被唤醒的线程.  
    * `notifyAll()`:唤醒在此同步锁对象上等待的所有线程,只有当前线程放弃对同步锁对象的锁定,才可能执行被唤醒的线程

## 区别
* sleep()和yield()的区别
  * sleep()使当前线程进入停滞状态,所以执行sleep()的线程在指定的时间内肯定不会被执行;yield()只是使当前线程重新回到可执行状态,所以执行yield()的线程有可能在进入到可执行状态后马上又被执行.
  * sleep方法使当前执行中的线程睡眠一段时间,进入不可执行状态,这段时间的长短是由程序设定的,yield方法使当前线程让出 CPU 占有权,但让出的时间是不可设定的.
  * yield()方法对应了如下操作:先检测当前是否有相同优先级的线程处于不可执行状态,如有,则把 CPU  的占有权交给此线程,否则,继续执行原来的线程.所以yield()方法称为"退让",它把执行机会让给了同等优先级的其他线程
  * sleep()方法允许较低优先级的线程获得执行机会,但 yield()方法执行时,当前线程仍处在可执行状态,所以,不可能让出较低优先级的线程些时获得 CPU 占有权.在一个执行系统中,如果较高优先级的线程没有调用`sleep`方法,又没有受到 I\O 阻塞,那么,较低优先级线程只能等待所有较高优先级的线程执行结束,才有机会执行. 




