## 应用层
### 本节方向
* 网络应用层的概念和实现
  * 客户端-服务器范式
  * 服务模型
* 通过对常用的应用层协议的探讨和分析来学习网络协议
* 深层次的目标：
  * http
  * ftp
  * smtp
  * pop
  * dns

### 应用程序和应用层协议
1. 应用程序：主要任务是沟通，普遍是分布式的进程
  * 运行在网络主机中的“用户空间”
  * 在应用层见交换报文  
  * E.G.，email, ftp,Web  
2. 应用层协议
  * 应用程序的一个“组成部分”  
  * 定义应用程序需交换的报文和采取的动作
  * 使用较低层次所提供的通信服务(TCP,UDP)

### 网络应用程序：一些术语
1. **进程(Process):**主机内运行中的程序。一台主机中可运行多个进程，俩进程使用进程间通信(由OS操作系统管理)。而运行在不同主机上的进程使用应用层协议进行通信。
2. **用户代理(User agent):**是一些软件进程，是介于用户和网络之间的接口，实现应用级协议，比如Web：浏览器;E-mail:OE、Foxmail;流媒体：media plaer。

### 客户端-服务器范式
* 典型的网络应用都是有两部分组成的：客户端和服务器  
* 客户端：发起同服务器的联系(speaks first)。一般从服务器请求服务，Web:客户端由浏览器实现;e-mail:通过OE、Foxmail实现
* 服务器：向客户端提供所请求的服务，保持持续的状态。e.g.Web服务器发送被请求的web页面，邮件服务器传递e-mail

###  应用层协议
* 应用程序接口(API：application programming interface):定义应用层和传输层间的接口
* 套接字(socket插口:Internet API):两个进程间的通信，将数据送入socket,或从socket读取数据
* 某个进程认定另一个需要与之通信的进程的方式：获取运行另一个进程的主机所拥有的IP地址，利用端口号，允许接收主机来确定的一个标识，本地进程将报文发送给他 
### 应用进程需要怎样的传输服务
1. 数据丢失(Data loss)
 * 某些应用(e.g.audio)可以容忍某种程度上的数据丢失
 * 其他应用(e.g.文件爱你差un数telnet)要求100%可靠数据传输
2. 实时性(Timing)
 * 某些应用(e.g.IP电话，交互式游戏)要求较低的时延
3. 带宽(Bandwidth)
 * 某些应用(e.g.多媒体)对最低带宽有要求
 * 其他应用(“弹性应用”)则可灵活应用所能得到的带宽

#### 常见应用程序对传输功能的要求
| 应用程序 | 数据丢失 | 带宽 | 实时性 |
|--- |----|----|----|
|文件传输|不允许丢失|弹性|无|
|E-mail|不允许丢失|弹性|无|
|Web网页|不允许丢失|弹性|无|
|实时音频/视频<br>存储音频/视频|允许丢失|**需求**音频:5kb-1Mb<br>视频:10kb-5Mb|100’s msec<br>few secs|
|交互式游戏|允许丢失|几Kb/s以上|100’s msec|
|金融应用|不允许丢失|弹性|可选|

### Internet的传输协议服务
1. TCP服务：
    * 面向连接：在客户端和服务器进程间需要建立连接(setup)
    * 可靠传输： 在发送和接受进程之间保证正确性
    * 流量控制：发送数据的速度绝不超过接收的速度 
    * 拥塞控制：当网络超负荷时，束紧发送端口，减缓发送速度  
    * 不提供：实时性，最小带宽承诺  
2. UDP服务： 
    * 在客户端和服务器进程之间实现“不可靠的”数据传输 
    * 不提供：连接建立，可靠性保证，流量控制，拥塞控制，实时性，最小带宽 

### http协议
* http:TCP传输服务：
  * 面向文件服务的，即主要是为了传输文件
  * 客户端启动TCP连接(创建插口)到服务器，端口80
  * 服务器接受来自客户端的TCP连接
  * http报文(应用层协议报文)：在浏览器(http client)和Web服务器(http server)之间进行交换
  * 关闭TCP连接
* http是“无状态”的stateless
  * 服务器不保留任何访问过的请求信息
  * 因为保留状态的协议会变的复杂，过去的历史状态需要保留，一旦浏览器/服务器崩溃，它们各自的状态试图会发生分歧，就需要重新核对，这对每天回应许多客户端的服务器来说是个很大的开销
* **举例**http工作过程
    假设用户在地址栏里键入了一个URL：www.xxx.com/somexxx/file.index并且文件中引用了10张jpg图片，我们用a表示客户端，b表示服务器端
  1. a  HTTP客户端启动TCP连接到www.xxx.com上的http服务器(进程)port80服务器默认端口
  1. b  在www.xxx.com上的http服务器上port80等待TCP的连接请求。“请求连接并通知客户端”
  2. a  http客户端发送http请求报文(包括url)进入TCP连接socket
  3. b  http服务器接收到请求报文形成响应报文(包含了所有请求的对象，打包到Socket) 
  4. b  当HTTP服务器将响应的数据发出后，随即就关闭了TCP连接。
  5. a  Http客户端接收到了包含html文件的响应报文分析html文件发现还有是个jpeg图片对象的引用
  6. a  对10个jpeg对象逐个重复以上5步

* 非持续和持续连接
  1.  Non-persistent(非持续连接):
    * http/1.0:服务器分析请求、响应、关闭、TCP连接
    * 取对象需要2RTTs:TCP连接，对象请求
    * 每次传送都要接受到TCP连接，初始化时的慢启动影响
    * 许多浏览器同时打开对个并行的连接来改善性能
  2.  Persistent(非持续连接)
    * http的默认设置
    * 在同一TCP连接上：服务器分析请求、响应请求、分析新的请求...一般情况下并非马上关闭连接
    * 客户端一旦下载到了基本html文件(baseHTML)会在原来的连接上马上发送所有引用对象的请求
    * 较少的RTTs减少了连接次数,较少的慢启动
* Http报文格式：request
  * http的报文格式分为两种：request，response
  * 请求报文ASCII可读格式:

  ```http
        GET /somedir/page.html HTTP/1.1
        //请求行GET,POST,HEAD命令，URL部分可以封装消息，一般有2000字节地址实际不可能这么长，所以会跟一些数据
        User-agent: Mozilla/4.0
        Accept: text/html, image/git,image/jpeg
        Accept-language:en-gb
        //首部诸多行与实体间有一个空行隔开表示实体开始

        //....实体部分
        //额外的carriage return,line feed。回车，换行代表报文结束
  ```

* HTTP报文格式：response(响应)
```http 
        HTTP/1.1 200 OK
        //状态行，协议、状态码404典型、状态短语
        DATA:Thu,06 Aug 1998 12:00:15 GMT
        Sever:Apache/1.3.0(Unix)
        Last-Modified:Mon,22 Jun 1998//最后修改时间...
        Content-Lenght:6821//内容长度
        Content-Type:text/html 
        //请求头诸行请求标签会被浏览器理解并处理掉

        data data data  data  
        //以空格开始的数据内容，包括被请求的html,xml,jsp等文件
```

* http响应状态码和短语
位于从服务器到客户端响应报文的第一行。
样例：
 * 200 OK：请求成功被请求的对象在报文中
 * 301 Moved Permanently:被请求的对象被移动过，新的位置在报文中(Location:)
 * 400 Bad Request:服务器无法辨识的请求报文

 * 404 Not Found:服务器上找不到请求的对象
 * 505 HTTP Version Not Supported:版本不支持

* 用户-服务器的交互：认证(authentication)
认证：控制对服务器内容的访问
信用认证：一般通过用户名，口令进行
无状态：客户端必须在每次请求前进行认证
 * authorization:就是要求在每个请求报文中提交认证的首部行
 * 如果客户端没有提交authorization：首部行，服务器将拒绝访问，只是在响应报文首部中发送WWW authenticate:认证请求
            client  ———普通http请求报文————> server
            client  <—401认证请求WWW authenticate:—— server
            client  —普通http报文请求+authenticate:——>server
            client  <—普通http响应报文—————  server
* Cookies:保存“状态”
 * 每次会话过程，服务器都产生一个cookie号码，服务器来认这个号码保存的Cookies内容，一般只在此次会话过程中有效用户可选择保存，每个Cookie一般不超过2K，以备不时之需：
   * 认证，记忆用户的前序访问，向前的选择
 * 服务器在响应报文中发送“cookie”给客户端
   * Set-cookie:2656545
 * 客户端可以在后继的请求中发送cookie
            client  ———普通http请求报文————> server
            client  <—普通htttp响应报文+Set-cookie:—— server
            client  —普通http请求请求cookie:——>server
            client  <—普通http响应报文—————  server
*Conditional GET:客户端缓存机制
 * 目的：如果客户端缓存了最新的请求对象，则服务器不必重复发送
 * 客户端：在HTTP请求报文中声明所缓存拷贝的生成日期
    ```
    If-modified-since：  
    <date>
    ```
 * 服务器：如果客户端缓存的拷贝是最新的，则在响应报文中不发请求的对象：
    ```
    HTTP/1.0 304 Not
    Modified
    ```

* Web缓存：代理服务器(proxy server)
目的：满足客户端的请求而无需烦扰原始服务器，代理服务器是一种普遍的网络机制。比如镜像网站其实也是一种代理，它会定期到原始网站更新数据信息。
 * 用户设置浏览器：
 Web访问经由代理服务器
 *  客户端发送所有的http请求到代理服务器
    代理服务器返回请求的对象,
 * 否则代理服务器从原始服务器请求对象，再将其返回到客户端
 * 因为访问资源可能带有同质性，减少往来与远程服务器之间的数据流量，响应时间更短，使访问速度更快。
