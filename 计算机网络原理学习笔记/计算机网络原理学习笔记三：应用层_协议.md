## 应用层
### 本节方向
* 网络应用层的概念和实现
  * 客户端-服务器范式
  * 服务模型
* 通过对常用的应用层协议的探讨和分析来学习网络协议
* 深层次的目标：
  * http
  * ftp
  * smtp
  * pop
  * dns

### 应用程序和应用层协议
1. 应用程序：主要任务是沟通，普遍是分布式的进程
  * 运行在网络主机中的“用户空间”
  * 在应用层见交换报文  
  * E.G.，email, ftp,Web  
2. 应用层协议
  * 应用程序的一个“组成部分”  
  * 定义应用程序需交换的报文和采取的动作
  * 使用较低层次所提供的通信服务(TCP,UDP)

### 网络应用程序：一些术语
1. **进程(Process):**主机内运行中的程序。一台主机中可运行多个进程，俩进程使用进程间通信(由OS操作系统管理)。而运行在不同主机上的进程使用应用层协议进行通信。
2. **用户代理(User agent):**是一些软件进程，是介于用户和网络之间的接口，实现应用级协议，比如Web：浏览器;E-mail:OE、Foxmail;流媒体：media plaer。

### 客户端-服务器范式
* 典型的网络应用都是有两部分组成的：客户端和服务器  
* 客户端：发起同服务器的联系(speaks first)。一般从服务器请求服务，Web:客户端由浏览器实现;e-mail:通过OE、Foxmail实现
* 服务器：向客户端提供所请求的服务，保持持续的状态。e.g.Web服务器发送被请求的web页面，邮件服务器传递e-mail

###  应用层协议
* 应用程序接口(API：application programming interface):定义应用层和传输层间的接口
* 套接字(socket插口:Internet API):两个进程间的通信，将数据送入socket,或从socket读取数据
* 某个进程认定另一个需要与之通信的进程的方式：获取运行另一个进程的主机所拥有的IP地址，利用端口号，允许接收主机来确定的一个标识，本地进程将报文发送给他 
### 应用进程需要怎样的传输服务
1. 数据丢失(Data loss)
 * 某些应用(e.g.audio)可以容忍某种程度上的数据丢失
 * 其他应用(e.g.文件爱你差un数telnet)要求100%可靠数据传输
2. 实时性(Timing)
 * 某些应用(e.g.IP电话，交互式游戏)要求较低的时延
3. 带宽(Bandwidth)
 * 某些应用(e.g.多媒体)对最低带宽有要求
 * 其他应用(“弹性应用”)则可灵活应用所能得到的带宽

#### 常见应用程序对传输功能的要求
| 应用程序 | 数据丢失 | 带宽 | 实时性 |
|--- |----|----|----|
|文件传输|不允许丢失|弹性|无|
|E-mail|不允许丢失|弹性|无|
|Web网页|不允许丢失|弹性|无|
|实时音频/视频<br>存储音频/视频|允许丢失|**需求**音频:5kb-1Mb<br>视频:10kb-5Mb|100’s msec<br>few secs|
|交互式游戏|允许丢失|几Kb/s以上|100’s msec|
|金融应用|不允许丢失|弹性|可选|

### Internet的传输协议服务
1. TCP服务：
    * 面向连接：在客户端和服务器进程间需要建立连接(setup)
    * 可靠传输： 在发送和接受进程之间保证正确性
    * 流量控制：发送数据的速度绝不超过接收的速度 
    * 拥塞控制：当网络超负荷时，束紧发送端口，减缓发送速度  
    * 不提供：实时性，最小带宽承诺  
2. UDP服务： 
    * 在客户端和服务器进程之间实现“不可靠的”数据传输 
    * 不提供：连接建立，可靠性保证，流量控制，拥塞控制，实时性，最小带宽 

### http协议
* http:TCP传输服务：
  * 面向文件服务的，即主要是为了传输文件
  * 客户端启动TCP连接(创建插口)到服务器，端口80
  * 服务器接受来自客户端的TCP连接
  * http报文(应用层协议报文)：在浏览器(http client)和Web服务器(http server)之间进行交换
  * 关闭TCP连接
* http是“无状态”的stateless
  * 服务器不保留任何访问过的请求信息
  * 因为保留状态的协议会变的复杂，过去的历史状态需要保留，一旦浏览器/服务器崩溃，它们各自的状态试图会发生分歧，就需要重新核对，这对每天回应许多客户端的服务器来说是个很大的开销
* **举例**http工作过程
    假设用户在地址栏里键入了一个URL：www.xxx.com/somexxx/file.index并且文件中引用了10张jpg图片，我们用a表示客户端，b表示服务器端
  1. a  HTTP客户端启动TCP连接到www.xxx.com上的http服务器(进程)port80服务器默认端口
  1. b  在www.xxx.com上的http服务器上port80等待TCP的连接请求。“请求连接并通知客户端”
  2. a  http客户端发送http请求报文(包括url)进入TCP连接socket
  3. b  http服务器接收到请求报文形成响应报文(包含了所有请求的对象，打包到Socket) 
  4. b  当HTTP服务器将响应的数据发出后，随即就关闭了TCP连接。
  5. a  Http客户端接收到了包含html文件的响应报文分析html文件发现还有是个jpeg图片对象的引用
  6. a  对10个jpeg对象逐个重复以上5步

* 非持续和持续连接
  1.  Non-persistent(非持续连接):
    * http/1.0:服务器分析请求、响应、关闭、TCP连接
    * 取对象需要2RTTs:TCP连接，对象请求
    * 每次传送都要接受到TCP连接，初始化时的慢启动影响
    * 许多浏览器同时打开对个并行的连接来改善性能
  2.  Persistent(非持续连接)
    * http的默认设置
    * 在同一TCP连接上：服务器分析请求、响应请求、分析新的请求...一般情况下并非马上关闭连接
    * 客户端一旦下载到了基本html文件(baseHTML)会在原来的连接上马上发送所有引用对象的请求
    * 较少的RTTs减少了连接次数,较少的慢启动
* Http报文格式：request
  * http的报文格式分为两种：request，response
  * 请求报文ASCII可读格式:

  ```http
        GET /somedir/page.html HTTP/1.0
        //请求行GET,POST,HEAD命令，URL部分可以封装消息，有2000字节地址不可能这么长，所以会跟一些数据
        User-agent: Mozilla/4.0
        Accept: text/html, image/git,image/jpeg
        Accept-language:fr
        //首部诸多行

        //....实体部分
        //额外的carriage return,line feed。回车，换行代表报文结束
  ```

